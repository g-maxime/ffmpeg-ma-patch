From e760b99e8d4c137b7765e381eaf233b57f833193 Mon Sep 17 00:00:00 2001
From: Jerome Martinez <jerome@mediaarea.net>
Date: Thu, 4 Dec 2025 17:31:32 +0100
Subject: [PATCH] decklink_dec: support labels

---
 fftools/ffprobe.c            |  27 +++++++--
 libavdevice/decklink_dec.cpp |  59 +++++++++++++------
 libavformat/dump.c           |   4 +-
 libavformat/matroska.h       |   1 +
 libavformat/matroskadec.c    |  72 +++++++++++++++--------
 libavformat/matroskaenc.c    | 111 ++++++++++++++++++++++++++++++++---
 libavutil/timecode.c         |  43 ++++++++++++++
 libavutil/timecode.h         |   4 ++
 8 files changed, 265 insertions(+), 56 deletions(-)

diff --git a/fftools/ffprobe.c b/fftools/ffprobe.c
index 92122e5277..b52da6e58a 100644
--- a/fftools/ffprobe.c
+++ b/fftools/ffprobe.c
@@ -969,6 +969,7 @@ static void print_pkt_side_data(AVTextFormatContext *tfc,
     const char *name = av_packet_side_data_name(sd->type);
 
     avtext_print_section_header(tfc, sd, id_data);
+    av_log(NULL, AV_LOG_ERROR, "%s \n", name ? name : "unknown");
     print_str("side_data_type", name ? name : "unknown");
     if (sd->type == AV_PKT_DATA_DISPLAYMATRIX && sd->size >= 9*4) {
         print_displaymatrix(tfc, (const int32_t*)sd->data);
@@ -1301,14 +1302,32 @@ static void print_frame_side_data(AVTextFormatContext *tfc,
             av_timecode_make_mpeg_tc_string(tcbuf, *(int64_t *)(sd->data));
             print_str("timecode", tcbuf);
         } else if (sd->type == AV_FRAME_DATA_S12M_TIMECODE && sd->size >= 8) {
-            uint64_t *tc = (uint64_t*)sd->data;
-            int m = FFMIN(tc[0],3);
+            uint8_t *sd_count = (uint8_t*) (sd->data + 4);
+            uint8_t count = *sd_count;
             avtext_print_section_header(tfc, NULL, SECTION_ID_FRAME_SIDE_DATA_TIMECODE_LIST);
-            for (int j = 1; j <= m ; j++) {
+            for (int j = 0; j < count ; j++) {
+                uint8_t *sd_base = sd->data + 8 + (8 + 4 + 16) * j;
+                uint64_t *sd_tc = (uint64_t*)sd_base;
+                uint32_t *sd_id = (uint32_t*)(sd_base + 8);
+                char* sd_title = (char*)(sd_base + 8 + 4);
                 char tcbuf[AV_TIMECODE_STR_SIZE];
-                av_timecode_make_smpte_tc_string2(tcbuf, stream->avg_frame_rate, tc[j], 0, 0);
+                uint64_t id = *sd_id;
+                uint64_t tc = *sd_tc;
+                av_timecode_make_smpte_tc_string2(tcbuf, stream->avg_frame_rate, av_timecode_parse_from_64bit(tc), 0, 0);
                 avtext_print_section_header(tfc, NULL, SECTION_ID_FRAME_SIDE_DATA_TIMECODE);
                 print_str("value", tcbuf);
+                print_int("id", id);
+                char tctitlebuf[17];
+                int k = 0;
+                for (; k < 16; k++)
+                    if (!sd_title[k])
+                        break;
+                if (k >= 16) {
+                    memcpy(tctitlebuf, sd_title, k);
+                    tctitlebuf[k] = '\0';
+                    sd_title = tctitlebuf;
+                }
+                print_str("title", sd_title);
                 avtext_print_section_footer(tfc);
             }
             avtext_print_section_footer(tfc);
diff --git a/libavdevice/decklink_dec.cpp b/libavdevice/decklink_dec.cpp
index 18596af2c2..4b6e7c56db 100644
--- a/libavdevice/decklink_dec.cpp
+++ b/libavdevice/decklink_dec.cpp
@@ -703,35 +703,49 @@ static int get_bmd_timecode(AVFormatContext *avctx, AVTimecode *tc, AVRational f
     return ret;
 }
 
-static int get_frame_timecode(AVFormatContext *avctx, decklink_ctx *ctx, AVTimecode *tc, IDeckLinkVideoInputFrame *videoFrame)
+static int get_frame_timecode(AVFormatContext *avctx, decklink_ctx *ctx, AVTimecode *tc, uint8_t *tc_kind, IDeckLinkVideoInputFrame *videoFrame)
 {
     AVRational frame_rate = ctx->video_st->r_frame_rate;
     int ret;
     if (ctx->tc_format == (BMDTimecodeFormat)1) {
         int count = 0;
         ret = get_bmd_timecode(avctx, tc + count, frame_rate, bmdTimecodeRP188VITC1, videoFrame);
-        if (ret != AVERROR(ENOENT))
+        if (ret != AVERROR(ENOENT)) {
+            tc_kind[count] = 0;
             count++;
+        }
         ret = get_bmd_timecode(avctx, tc + count, frame_rate, bmdTimecodeRP188VITC2, videoFrame);
-        if (ret != AVERROR(ENOENT))
+        if (ret != AVERROR(ENOENT)) {
+            tc_kind[count] = 1;
             count++;
+        }
         ret = get_bmd_timecode(avctx, tc + count, frame_rate, bmdTimecodeRP188LTC, videoFrame);
-        if (ret != AVERROR(ENOENT))
-            count++;
-#if BLACKMAGIC_DECKLINK_API_VERSION >= 0x0b000000
-        ret = get_bmd_timecode(avctx, tc + count, frame_rate, bmdTimecodeRP188HighFrameRate, videoFrame);
-        if (ret != AVERROR(ENOENT))
+        if (ret != AVERROR(ENOENT)) {
+            tc_kind[count] = 2;
             count++;
-#endif
+        }
         ret = get_bmd_timecode(avctx, tc + count, frame_rate, bmdTimecodeVITC, videoFrame);
-        if (ret != AVERROR(ENOENT))
+        if (ret != AVERROR(ENOENT)) {
+            tc_kind[count] = 3;
             count++;
+        }
         ret = get_bmd_timecode(avctx, tc + count, frame_rate, bmdTimecodeVITCField2, videoFrame);
-        if (ret != AVERROR(ENOENT))
+        if (ret != AVERROR(ENOENT)) {
+            tc_kind[count] = 4;
             count++;
+        }
         ret = get_bmd_timecode(avctx, tc + count, frame_rate, bmdTimecodeSerial, videoFrame);
-        if (ret != AVERROR(ENOENT))
+        if (ret != AVERROR(ENOENT)) {
+            tc_kind[count] = 5;
             count++;
+        }
+#if BLACKMAGIC_DECKLINK_API_VERSION >= 0x0b000000
+        ret = get_bmd_timecode(avctx, tc + count, frame_rate, bmdTimecodeRP188HighFrameRate, videoFrame);
+        if (ret != AVERROR(ENOENT)) {
+            tc_kind[count] = 6;
+            count++;
+        }
+#endif
        return count;
     }
     /* 50/60 fps content has alternating VITC1 and VITC2 timecode (see SMPTE ST
@@ -847,7 +861,8 @@ HRESULT decklink_input_callback::VideoInputFrameArrived(
             // Handle Timecode (if requested)
             if (ctx->tc_format) {
                 AVTimecode tcr[8];
-                int count = get_frame_timecode(avctx, ctx, &tcr[0], videoFrame);
+                uint8_t tcr_kind[8];
+                int count = get_frame_timecode(avctx, ctx, &tcr[0], &tcr_kind[0], videoFrame);
                 if (count > 0) {
                     char tcstr[AV_TIMECODE_STR_SIZE];
                     const char *tc = av_timecode_make_string(&tcr[0], tcstr, 0);
@@ -856,13 +871,23 @@ HRESULT decklink_input_callback::VideoInputFrameArrived(
                         uint8_t* packed_metadata;
 
                         if (av_cmp_q(ctx->video_st->r_frame_rate, av_make_q(60, 1)) < 1) {
-                            int size = sizeof(uint64_t) * (1 + count);
-                            uint64_t *sd = (uint64_t *)av_packet_new_side_data(&pkt, AV_PKT_DATA_S12M_TIMECODE, size);
+                            int sd_size = 8 + count * (8 + 4 + 16);
+                            uint8_t *sd = av_packet_new_side_data(&pkt, AV_PKT_DATA_S12M_TIMECODE, sd_size);
+                            uint32_t *sd_allocated = (uint32_t*)sd;
+                            *sd_allocated = sd_size;
+                            uint8_t *item_size = sd + 5;
+                            *item_size = 8 + 4 + 16;
 
                             if (sd) {
                                 *sd = count;
-                                for (int i = 0; i < count; i++)
-                                    *(sd + 1 + i) = av_timecode_expand_to_64bit(av_timecode_get_smpte_from_framenum(&tcr[i], 0));
+                                for (int i = 0; i < count; i++) {
+                                    uint64_t tc = av_timecode_expand_to_64bit(av_timecode_get_smpte_from_framenum(&tcr[i], 0));
+                                    size_t tc_kind = tcr_kind[i];
+                                    if (tc_kind > 7)
+                                        av_log(ctx, AV_LOG_ERROR, "******* TC kind unknown.\n");
+                                    static const char* A[] = { "ATC_VITC", "ATC_VITC2", "ATC_LTC", "VITC", "VITC2", "VITC2", "9PIN", "HFRTC" };
+                                    av_timecode_add_to_side_data(avctx, &pkt, 3 /* id + title */, tc, 0, A[tc_kind]);
+                                }
                             }
                         }
 
diff --git a/libavformat/dump.c b/libavformat/dump.c
index a5cdf0b45b..45e83c88e0 100644
--- a/libavformat/dump.c
+++ b/libavformat/dump.c
@@ -433,7 +433,7 @@ static void dump_s12m_timecode(void *ctx, AVRational avg_frame_rate, const AVPac
 {
     const uint32_t *tc = (const uint32_t *)sd->data;
 
-    if ((sd->size != sizeof(uint32_t) * 4) || (tc[0] > 3)) {
+    if (sd->size < sizeof(uint32_t)) {
         av_log(ctx, AV_LOG_ERROR, "invalid data\n");
         return;
     }
@@ -477,7 +477,7 @@ static void dump_sidedata(void *ctx, const AVPacketSideData *side_data, int nb_s
     int i;
 
     if (nb_side_data)
-        av_log(ctx, log_level, "%sSide data:\n", indent);
+        av_log(ctx, AV_LOG_ERROR, "%sSide data:\n", indent);
 
     for (i = 0; i < nb_side_data; i++) {
         const AVPacketSideData *sd = &side_data[i];
diff --git a/libavformat/matroska.h b/libavformat/matroska.h
index d78b33d4b2..84debcfd64 100644
--- a/libavformat/matroska.h
+++ b/libavformat/matroska.h
@@ -223,6 +223,7 @@
 #define MATROSKA_ID_TAGTARGETS_TRACKUID   0x63C5
 #define MATROSKA_ID_TAGTARGETS_CHAPTERUID 0x63C4
 #define MATROSKA_ID_TAGTARGETS_ATTACHUID  0x63C6
+#define MATROSKA_ID_TAGTARGETS_BLOCKADDID 0x63C7
 
 /* IDs in the seekhead master */
 #define MATROSKA_ID_SEEKENTRY  0x4DBB
diff --git a/libavformat/matroskadec.c b/libavformat/matroskadec.c
index d8800b48a6..759d4a64f8 100644
--- a/libavformat/matroskadec.c
+++ b/libavformat/matroskadec.c
@@ -49,6 +49,7 @@
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/time_internal.h"
+#include "libavutil/timecode.h"
 #include "libavutil/spherical.h"
 
 #include "libavcodec/bytestream.h"
@@ -259,6 +260,7 @@ typedef struct MatroskaBlockAdditionMapping {
     char *name;
     uint64_t type;
     EbmlBin extradata;
+    char *title;
 } MatroskaBlockAdditionMapping;
 
 typedef struct MatroskaTrack {
@@ -341,6 +343,7 @@ typedef struct MatroskaTagTarget {
     uint64_t trackuid;
     uint64_t chapteruid;
     uint64_t attachuid;
+    uint64_t blockaddid;
 } MatroskaTagTarget;
 
 typedef struct MatroskaTags {
@@ -449,7 +452,7 @@ typedef struct MatroskaDemuxContext {
 // Removing the sizes breaks MSVC.
 static EbmlSyntax ebml_syntax[3], matroska_segment[9], matroska_track_video_color[15], matroska_track_video[19],
                   matroska_track[33], matroska_track_encoding[6], matroska_track_encodings[2],
-                  matroska_track_combine_planes[2], matroska_track_operation[2], matroska_block_addition_mapping[5], matroska_tracks[2],
+                  matroska_track_combine_planes[2], matroska_track_operation[2], matroska_block_addition_mapping[6], matroska_tracks[2],
                   matroska_attachments[2], matroska_chapter_entry[9], matroska_chapter[6], matroska_chapters[2],
                   matroska_index_entry[3], matroska_index[2], matroska_tag[3], matroska_tags[2], matroska_seekhead[2],
                   matroska_blockadditions[2], matroska_blockgroup[8], matroska_cluster_parsing[8];
@@ -604,6 +607,7 @@ static EbmlSyntax matroska_block_addition_mapping[] = {
     { MATROSKA_ID_BLKADDIDNAME,       EBML_STR,  0, 0, offsetof(MatroskaBlockAdditionMapping, name) },
     { MATROSKA_ID_BLKADDIDTYPE,       EBML_UINT, 0, 0, offsetof(MatroskaBlockAdditionMapping, type), { .u = MATROSKA_BLOCK_ADD_ID_TYPE_DEFAULT } },
     { MATROSKA_ID_BLKADDIDEXTRADATA,  EBML_BIN,  0, 0, offsetof(MatroskaBlockAdditionMapping, extradata) },
+    { MATROSKA_ID_BLKADDIDTYPE,       EBML_UTF8, 0, 0, offsetof(MatroskaBlockAdditionMapping, title) }, //TODO: fake ID, used here for freeing the char* automatically
     CHILD_OF(matroska_track)
 };
 
@@ -731,6 +735,7 @@ static EbmlSyntax matroska_tagtargets[] = {
     { MATROSKA_ID_TAGTARGETS_TRACKUID,   EBML_UINT, 0, 0, offsetof(MatroskaTagTarget, trackuid),   { .u = 0 } },
     { MATROSKA_ID_TAGTARGETS_CHAPTERUID, EBML_UINT, 0, 0, offsetof(MatroskaTagTarget, chapteruid), { .u = 0 } },
     { MATROSKA_ID_TAGTARGETS_ATTACHUID,  EBML_UINT, 0, 0, offsetof(MatroskaTagTarget, attachuid),  { .u = 0 } },
+    { MATROSKA_ID_TAGTARGETS_BLOCKADDID, EBML_UINT, 0, 0, offsetof(MatroskaTagTarget, blockaddid), { .u = 0 } },
     CHILD_OF(matroska_tag)
 };
 
@@ -1846,6 +1851,35 @@ static void matroska_convert_tag(AVFormatContext *s, EbmlList *list,
     ff_metadata_conv(metadata, NULL, ff_mkv_metadata_conv);
 }
 
+static void matroska_convert_blockaddid_tag(AVFormatContext *s, EbmlList *list,
+                                 const EbmlList *mappings_list, uint64_t mappings_id)
+{
+    MatroskaTag *tags = list->elem;
+    MatroskaBlockAdditionMapping *mappings = mappings_list->elem;
+    int i;
+
+    for (i = 0; i < list->nb_elem; i++) {
+        const char *lang = tags[i].lang &&
+                           strcmp(tags[i].lang, "und") ? tags[i].lang : NULL;
+                           
+        if (lang)
+            continue; // Only the default one
+
+        if (!tags[i].name) {
+            av_log(s, AV_LOG_WARNING, "Skipping invalid tag with no TagName.\n");
+            continue;
+        }
+        for (int j = 0; j < mappings_list->nb_elem; j++) {
+            MatroskaBlockAdditionMapping *mapping = &mappings[j];
+            uint64_t id = mapping->value;
+            if (mappings_id != id)
+                continue;
+            av_log(s, AV_LOG_ERROR, "blockaddid %"PRId64", title is %s\n", id, tags[i].string);
+            mapping->title = av_strdup(tags[i].string);
+        }
+    }
+}
+
 static void matroska_convert_tags(AVFormatContext *s)
 {
     MatroskaDemuxContext *matroska = s->priv_data;
@@ -1893,7 +1927,12 @@ static void matroska_convert_tags(AVFormatContext *s)
             for (j = 0; j < matroska->tracks.nb_elem; j++) {
                 if (track[j].uid == tags[i].target.trackuid &&
                     track[j].stream) {
-                    matroska_convert_tag(s, &tags[i].tag,
+                    if (tags[i].target.blockaddid) {
+                        matroska_convert_blockaddid_tag(s, &tags[i].tag,
+                                         &track->block_addition_mappings, tags[i].target.blockaddid);
+                    }
+                    else 
+                        matroska_convert_tag(s, &tags[i].tag,
                                          &track[j].stream->metadata, NULL);
                     found = 1;
                }
@@ -3964,29 +4003,12 @@ static int matroska_parse_block_additional(MatroskaDemuxContext *matroska,
             break;
         }
 
-        size_t sd_size = 0;
-        uint8_t *sd = av_packet_get_side_data(pkt, AV_PKT_DATA_S12M_TIMECODE, &sd_size);
-        uint64_t count = sd ? *((uint64_t*)sd) : 0;
-        if (!count) {
-            sd_size = sizeof(uint64_t) * (1 + track->add_block_timecode_count);
-            sd = av_packet_new_side_data(pkt, AV_PKT_DATA_S12M_TIMECODE, sd_size);
-            count = 0;
-        }
-
-        if (count >= track->add_block_timecode_count) {
-            av_log(matroska->ctx, AV_LOG_DEBUG, "There are more timecodes in the block than the count indicated in the track header, extra timecodes are ignored.\n");
-        }
-        else if (sd) {
-            uint64_t tc = *((uint64_t*)data);
-            av_log(matroska->ctx, AV_LOG_DEBUG, "Reading SMPTE timecode from BlockAdditional: 0x%016lX (RFC 5484)\n", tc);
-
-            uint64_t *sd_64 = (uint64_t*)sd;
-            count++;
-            *sd_64 = count;
-            AV_WB64(sd_64 + count, tc);
-        }
-        
-        return 0;
+        uint64_t tc = AV_RB64(data);
+        static size_t tc_kind = -1;
+        tc_kind++;
+        if (tc_kind >= 3)
+            tc_kind = 0;
+        return av_timecode_add_to_side_data(matroska->ctx, pkt, 3 /* id + title */, tc, id, mapping->title);
     }
     default:
         break;
diff --git a/libavformat/matroskaenc.c b/libavformat/matroskaenc.c
index 923e18fa1e..c6ccb48d0b 100644
--- a/libavformat/matroskaenc.c
+++ b/libavformat/matroskaenc.c
@@ -201,9 +201,11 @@ typedef struct mkv_track {
     int64_t         last_timestamp;
     int64_t         duration;
     int64_t         duration_offset;
+    int64_t         more_tags_offset;
     uint64_t        max_blockaddid;
     int             itu_t_t35_count;
     int             timecode_count;
+    char            timecode_label[8][16];
     int64_t         blockadditionmapping_offset;
     int             codecpriv_offset;
     unsigned        codecpriv_size;     ///< size reserved for CodecPrivate excluding header+length field
@@ -3480,6 +3482,46 @@ static int mkv_write_tags(AVFormatContext *s)
             return ret;
         if (seekable)
             track->duration_offset = avio_tell(mkv->tags.bc) - DURATION_SIMPLETAG_SIZE;
+
+        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
+        {
+            /*
+            AVIOContext *pb = mkv->tmp_bc;
+            ebml_master targets;
+
+            targets = start_ebml_master(pb, MATROSKA_ID_TAGTARGETS, 4 + 1 + 8);
+            put_ebml_uid(pb, MATROSKA_ID_TAGTARGETS_TRACKUID, track->uid);
+            put_ebml_uint(pb, MATROSKA_ID_TAGTARGETS_BLOCKADDID, 101);
+            end_ebml_master(pb, targets);
+            
+            targets = start_ebml_master(pb, MATROSKA_ID_SIMPLETAG, 4 + 1 + 8);
+            put_ebml_string(pb, MATROSKA_ID_TAGNAME, "VITC");
+            end_ebml_master(pb, targets);
+
+            
+
+            uint8_t *buf;
+            int ret = 0, size, tag_written = 0;
+
+            AVIOContext *const tmp_bc = pb;
+            size = avio_get_dyn_buf(tmp_bc, &buf);
+            if (tmp_bc->error) {
+                ret = tmp_bc->error;
+                //goto end;
+            }
+            if (!pb) {
+                ret = start_ebml_master_crc32(&pb, mkv);
+                //if (ret < 0)
+                    //goto end;
+            }
+            ffio_reset_dyn_buf(pb);
+            put_ebml_binary(mkv->tags.bc, MATROSKA_ID_TAG, buf, size);
+            */
+
+            track->more_tags_offset = avio_tell(mkv->tags.bc);
+            put_ebml_void(mkv->tags.bc, 8 * 32);
+
+        }
     }
 
     if (mkv->nb_attachments && !IS_WEBM(mkv)) {
@@ -4089,12 +4131,16 @@ static int mkv_write_block(void *logctx, MatroskaMuxContext *mkv,
     uint64_t count = 0;
     if (par->codec_type == AVMEDIA_TYPE_VIDEO) {
         side_data = av_packet_get_side_data(pkt, AV_PKT_DATA_S12M_TIMECODE, &side_data_size);
-        if (side_data && side_data_size >= sizeof(uint64_t)) {
-            uint64_t *side_data_64 = (uint64_t*)side_data;
-            count = side_data_64[0];
-            if (side_data_size / sizeof(uint64_t) - 1 >= count ) {
+        if (side_data && side_data_size >= 8) {
+
+            // header: 0-3 allocated size; 4 count; 5 byte size per item; 6 flags; 7 reserved
+            // flags: 0 id present; 1 title present
+            // content: 8 bytes tc; 4 bytes id; 16 bytes 0 terminated or 16 bytes UTF8 title
+
+            uint8_t count = *(side_data + 4);
+            uint8_t item_size = *(side_data + 5);
+            if (item_size && (side_data_size - 8) / item_size >= count ) {
                 uint64_t written_count = count;
-                side_data_64++;
                 if (count > MAX_MATROSKA_BLOCK_ADD_SMPTE_12M) {
                     if (count > track->timecode_count) {
                         av_log(logctx, AV_LOG_WARNING, "Too many SMPTE timecode streams in side data, discarding %"PRIu64" timecode streams.\n", count - MAX_MATROSKA_BLOCK_ADD_SMPTE_12M);
@@ -4102,10 +4148,15 @@ static int mkv_write_block(void *logctx, MatroskaMuxContext *mkv,
                     written_count = MAX_MATROSKA_BLOCK_ADD_SMPTE_12M;
                 }
                 for (uint64_t i = 0; i < written_count; i++) {
-                    uint64_t tc = side_data_64[i];
+                    uint8_t *sd_base = side_data + 8 + item_size * i;
+                    uint64_t *sd_tc = (uint64_t*)sd_base;
+                    uint32_t *sd_id = (uint32_t*)(sd_base + 8);
+                    char* sd_title = (char*)(sd_base + 8 + 4);
                     uint8_t *payload = timecode_buf[i];
-                    AV_WB64(payload, tc);
-                    av_log(logctx, AV_LOG_DEBUG, "Writing SMPTE timecode from side data, pos %"PRIu64", to BlockAdditional: 0x%016lX (RFC 5484)\n", i + 1, tc);
+                    AV_WB64(payload, *sd_tc);
+                    memcpy(track->timecode_label[i], sd_title, 16);
+                    
+                    av_log(logctx, AV_LOG_DEBUG, "Writing SMPTE timecode from side data, pos %"PRIu64", to BlockAdditional: 0x%016lX (RFC 5484)\n", i + 1, *sd_tc);
 
                     int blockaddid = MATROSKA_BLOCK_ADD_ID_SMPTE_12M + i;
                     mkv_write_blockadditional(&writer, payload, 8, blockaddid);
@@ -4582,6 +4633,50 @@ after_cues:
                 if (remaining_video_track_space > 1) {
                     put_ebml_void(track_bc, remaining_video_track_space);
                 }
+                
+                int remaining_bytes = 8 * 32;
+                AVIOContext *pb = mkv->tmp_bc;
+                
+                avio_seek(mkv->tags.bc, track->more_tags_offset, SEEK_SET);
+
+                for (int i = 0; i < track->timecode_count; i++) {
+                    if (!*track->timecode_label[i])
+                        continue;
+                    
+                    ebml_master targets;
+
+                    targets = start_ebml_master(pb, MATROSKA_ID_TAGTARGETS, 4 + 1 + 8);
+                    put_ebml_uid(pb, MATROSKA_ID_TAGTARGETS_TRACKUID, track->uid);
+                    put_ebml_uint(pb, MATROSKA_ID_TAGTARGETS_BLOCKADDID, 101 + i);
+                    end_ebml_master(pb, targets);
+
+                    targets = start_ebml_master(pb, MATROSKA_ID_SIMPLETAG, 4 + 1 + 8);
+                    put_ebml_string(pb, MATROSKA_ID_TAGNAME, "TITLE");
+                    put_ebml_string(pb, MATROSKA_ID_TAGSTRING, track->timecode_label[i]);
+                    end_ebml_master(pb, targets);
+
+
+
+                    uint8_t *buf;
+                    int ret = 0, size, tag_written = 0;
+
+                    AVIOContext *const tmp_bc = pb;
+                    size = avio_get_dyn_buf(tmp_bc, &buf);
+                    if (tmp_bc->error) {
+                        ret = tmp_bc->error;
+                        //goto end;
+                    }
+                    if (!pb) {
+                        ret = start_ebml_master_crc32(&pb, mkv);
+                        //if (ret < 0)
+                            //goto end;
+                    }
+                    ffio_reset_dyn_buf(pb);
+                    
+                    put_ebml_binary(mkv->tags.bc, MATROSKA_ID_TAG, buf, size);
+                    remaining_bytes -= 3 + size;
+                }
+                put_ebml_void(mkv->tags.bc, remaining_bytes);
             }
         }
 
diff --git a/libavutil/timecode.c b/libavutil/timecode.c
index 81fb66a5e4..2c054f987c 100644
--- a/libavutil/timecode.c
+++ b/libavutil/timecode.c
@@ -347,3 +347,46 @@ uint32_t av_timecode_parse_from_64bit(uint64_t tc64)
 
     return tc32;
 }
+
+int av_timecode_add_to_side_data(AVFormatContext *ctx, AVPacket *pkt, unsigned flags, uint64_t tc, uint32_t id, const char *title)
+{
+    const int add_block_timecode_count = 4; //TODO
+    size_t sd_size = 0;
+    uint8_t *sd = av_packet_get_side_data(pkt, AV_PKT_DATA_S12M_TIMECODE, &sd_size);
+    uint8_t count = sd ? *((uint8_t*) (sd + 4)) : 0;
+    if (!count) {
+        sd_size = 8 + add_block_timecode_count * (8 + 4 + 16);
+        sd = av_packet_new_side_data(pkt, AV_PKT_DATA_S12M_TIMECODE, sd_size);
+        uint32_t *sd_allocated = (uint32_t*)sd;
+        *sd_allocated = sd_size;
+        uint8_t *item_size = sd + 5;
+        *item_size = 8 + 4 + 16;
+        count = 0;
+    }
+
+    if (count >= add_block_timecode_count) {
+        av_log(ctx, AV_LOG_DEBUG, "There are more timecodes in the block than the count indicated in the track header, extra timecodes are ignored.\n");
+    }
+    else if (sd) {
+        av_log(ctx, AV_LOG_DEBUG, "Reading SMPTE timecode from BlockAdditional: 0x%016lX (RFC 5484)\n", tc);
+
+        // header: 0-3 allocated size; 4 count; 5 byte size per item; 6 flags; 7 reserved
+        // flags: 0 id present; 1 title present
+        // content: 8 bytes tc; 4 bytes id; 16 bytes 0 terminated or 16 bytes UTF8 title
+
+        count++;
+        uint8_t *sd_count = (uint8_t*) (sd + 4);
+        *sd_count = count;
+        uint8_t *sd_base = sd + 8 + (8 + 4 + 16) * (count - 1);
+        uint64_t *sd_tc = (uint64_t*)sd_base;
+        uint32_t *sd_id = (uint32_t*)(sd_base + 8);
+        char* sd_title = (char*)(sd_base + 8 + 4);
+        *sd_tc = tc;
+        *sd_id = id;
+        size_t title_size = strlen(title);
+        memcpy(sd_title, title, title_size);
+        memset(sd_title + title_size, 0, 16 - title_size);
+    }
+    
+    return 0;
+}
\ No newline at end of file
diff --git a/libavutil/timecode.h b/libavutil/timecode.h
index 81713a9adf..b1f140c9bf 100644
--- a/libavutil/timecode.h
+++ b/libavutil/timecode.h
@@ -28,6 +28,8 @@
 #define AVUTIL_TIMECODE_H
 
 #include <stdint.h>
+#include "libavformat/avformat.h"
+#include "libavcodec/packet.h"
 #include "rational.h"
 
 #define AV_TIMECODE_STR_SIZE 23
@@ -218,4 +220,6 @@ uint64_t av_timecode_expand_to_64bit(uint32_t tc32);
  */
 uint32_t av_timecode_parse_from_64bit(uint64_t tc64);
 
+int av_timecode_add_to_side_data(AVFormatContext *ctx, AVPacket *pkt, unsigned flags, uint64_t tc, uint32_t id, const char *title);
+
 #endif /* AVUTIL_TIMECODE_H */
-- 
2.46.0.windows.1

